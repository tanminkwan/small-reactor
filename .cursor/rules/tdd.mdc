---
description: TDD(Test-Driven Development) 기반 코딩 진행 기준
globs: ["**/*.py", "**/*.ts", "**/*.js", "**/*.tsx", "**/*.jsx", "**/*.java", "**/*.cs", "**/*.cpp", "**/*.c"]
alwaysApply: true
---

# TDD(Test-Driven Development) 기반 코딩 진행 기준

## 1. TDD 기본 원칙
- **Red-Green-Refactor 사이클**: 테스트 실패 → 구현 → 리팩토링
- **테스트 우선 개발**: 모든 기능 구현 전에 테스트 코드 작성
- **지속적인 피드백**: 빠른 피드백을 통한 품질 보장
- **작은 단위로 개발**: 한 번에 하나의 기능만 구현

## 2. TDD 개발 프로세스

### 2.1 Red 단계 (실패하는 테스트 작성)
- 구현하고자 하는 기능에 대한 테스트를 먼저 작성
- 테스트가 실패하는 것을 확인 (아직 구현되지 않았으므로)
- 테스트는 구체적이고 명확해야 함
- 테스트 이름은 기능과 예상 결과를 명확히 표현

### 2.2 Green 단계 (테스트 통과하는 최소한의 코드 작성)
- 테스트를 통과하는 최소한의 코드만 작성
- 완벽하지 않아도 됨 (일단 통과시키는 것이 목표)
- 복잡한 로직은 나중에 리팩토링
- 코드 품질보다는 테스트 통과에 집중

### 2.3 Refactor 단계 (코드 개선)
- 테스트가 통과하는 상태에서 코드 개선
- 중복 제거, 가독성 향상, 성능 최적화
- SOLID 원칙 준수
- 리팩토링 후에도 모든 테스트가 통과해야 함

## 3. 테스트 작성 가이드라인

### 3.1 테스트 명명 규칙
```python
# Python 예시
def test_<기능>_<조건>_<예상결과>():
    pass

# 예시
def test_detect_faces_with_valid_image_returns_face_list():
    pass

def test_detect_faces_with_invalid_image_raises_exception():
    pass
```

### 3.2 테스트 구조 (AAA 패턴)
```python
def test_example():
    # Arrange - 테스트 데이터 준비
    input_data = create_test_data()
    service = create_service()
    
    # Act - 테스트 실행
    result = service.process(input_data)
    
    # Assert - 결과 검증
    assert result is not None
    assert result.status == "success"
```

### 3.3 테스트 범위
- **단위 테스트**: 개별 함수/메서드 테스트
- **통합 테스트**: 컴포넌트 간 상호작용 테스트
- **E2E 테스트**: 전체 시스템 시나리오 테스트

## 4. Mock 사용 가이드라인

### 4.1 Mock 사용 원칙
- 외부 의존성은 Mock으로 대체
- 테스트 대상 코드만 테스트
- Mock은 실제 동작과 유사하게 구현
- Mock 설정은 명확하고 이해하기 쉽게

### 4.2 Mock 예시
```python
@pytest.fixture
def mock_face_detector():
    with patch('src.services.buffalo_detector.FaceAnalysis') as mock:
        mock_instance = mock.return_value
        mock_instance.get.return_value = [create_mock_face()]
        yield mock_instance

def test_orchestrator_with_mock_detector(mock_face_detector):
    # Mock을 사용한 테스트
    pass
```

## 5. 테스트 품질 기준

### 5.1 테스트 커버리지
- **전체 커버리지**: 90% 이상
- **핵심 비즈니스 로직**: 95% 이상
- **에러 처리 코드**: 100%

### 5.2 테스트 품질 체크리스트
- [ ] 테스트가 독립적으로 실행 가능한가?
- [ ] 테스트가 실제 사용 시나리오를 반영하는가?
- [ ] 테스트 이름이 명확하고 이해하기 쉬운가?
- [ ] 테스트가 하나의 기능만 검증하는가?
- [ ] 테스트가 빠르게 실행되는가?
- [ ] 테스트가 안정적으로 실행되는가?

## 6. TDD 개발 체크리스트

### 6.1 기능 개발 전
- [ ] 구현할 기능에 대한 테스트를 작성했는가?
- [ ] 테스트가 실패하는 것을 확인했는가?
- [ ] 테스트가 구체적이고 명확한가?

### 6.2 기능 구현 중
- [ ] 테스트를 통과하는 최소한의 코드를 작성했는가?
- [ ] 모든 테스트가 통과하는가?
- [ ] 새로운 기능이 기존 기능을 깨뜨리지 않는가?

### 6.3 기능 완성 후
- [ ] 코드를 리팩토링했는가?
- [ ] SOLID 원칙을 준수하는가?
- [ ] 모든 테스트가 여전히 통과하는가?
- [ ] 코드가 읽기 쉽고 유지보수하기 쉬운가?

## 7. TDD 위반 시 대응

### 7.1 테스트 없이 코드 작성 시
- 즉시 해당 기능에 대한 테스트 작성
- 기존 코드를 테스트로 감싸기
- 리팩토링을 통해 테스트 가능한 구조로 변경

### 7.2 테스트 실패 시
- 테스트 실패 원인 분석
- 코드 수정 또는 테스트 수정
- 모든 테스트가 통과할 때까지 반복

## 8. TDD 도구 및 설정

### 8.1 필수 도구
- **pytest**: Python 테스트 프레임워크
- **pytest-cov**: 테스트 커버리지 측정
- **pytest-mock**: Mock 객체 생성
- **pytest-xdist**: 병렬 테스트 실행

### 8.2 테스트 실행 명령어
```bash
# 모든 테스트 실행
pytest

# 커버리지와 함께 실행
pytest --cov=src --cov-report=html

# 특정 테스트만 실행
pytest tests/test_specific.py

# 병렬 실행
pytest -n auto
```

## 9. TDD와 SOLID 원칙 연계

### 9.1 단일 책임 원칙 (SRP)
- 각 클래스별로 명확한 테스트 범위 설정
- 하나의 클래스는 하나의 책임만 테스트

### 9.2 의존성 역전 원칙 (DIP)
- Mock 객체를 통한 의존성 격리
- 인터페이스 기반 테스트 작성

### 9.3 인터페이스 분리 원칙 (ISP)
- 인터페이스별 테스트 분리
- 필요한 기능만 테스트

## 10. TDD 성공 지표

### 10.1 품질 지표
- **테스트 커버리지**: 90% 이상
- **테스트 통과율**: 100%
- **TDD 준수율**: 100%
- **리팩토링 빈도**: 지속적

### 10.2 개발 효율성 지표
- **버그 발견 시간**: 개발 중 즉시 발견
- **리그레션 버그**: 최소화
- **코드 품질**: 지속적 향상
- **유지보수성**: 높은 수준 유지

## 결론

TDD는 단순한 테스트 작성 방법이 아니라, 높은 품질의 코드를 지속적으로 생산하는 개발 방법론입니다. 이 규칙을 준수하여 개발하면 버그가 적고, 유지보수가 쉬우며, 확장 가능한 코드를 작성할 수 있습니다.
